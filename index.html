<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Runes — Idle</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --card:#fafafa; --line:#e6e6e6; --muted:#555; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#fff; color:#111; margin:0; }
    header { padding:24px 16px; text-align:center; border-bottom:1px solid var(--line); }
    h1 { margin:0 0 4px 0; font-size:28px; }
    .sub { color:var(--muted); font-size:14px; }
    main { max-width:860px; margin: 20px auto; padding: 0 16px 40px; }

    .statbar { display:flex; gap:16px; flex-wrap:wrap; align-items:center; justify-content:center; margin: 18px 0; }
    .pill { padding:8px 14px; border:1px solid var(--line); border-radius:999px; background:#fff; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size:13px; color:var(--muted); }

    .actions { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin: 8px 0 18px; }
    button { font-size:16px; padding:10px 18px; border-radius:10px; border:1px solid var(--line); background:#111; color:#fff; cursor:pointer; }
    button:disabled { background:#ddd; color:#888; cursor:not-allowed; }
    .mutelink { background:#f6f6f6; color:#111; }

    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:16px; }
    .card { background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px; }
    .card h3 { margin:0 0 8px 0; }
    .row { display:flex; justify-content:space-between; align-items:center; padding:6px 0; }
    .badge { padding:3px 8px; border-radius:999px; font-weight:700; font-size:13px; }
    .common { background:#eef; }
    .rare { background:#e6ffe6; }
    .epic { background:#fae6ff; }
    .legend { background:#fff0d6; }
    .mythic { background:#ffe6e6; }

    /* Leaderboard table */
    .lb-table { width:100%; border-collapse:collapse; }
    .lb-table th, .lb-table td { padding:8px 10px; border-bottom:1px solid var(--line); text-align:left; }
    .lb-table th { font-size:13px; color:var(--muted); font-weight:600; }
    .lb-table td.rank { width:48px; font-weight:700; }

    /* Modal */
    .modal-backdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,.25);
      display:flex; align-items:center; justify-content:center; padding:16px;
    }
    .modal {
      background:#fff; width:100%; max-width:420px; border-radius:14px; padding:16px;
      border:1px solid var(--line);
    }
    .modal h2 { margin: 0 0 8px 0; }
    .field { display:flex; gap:8px; margin-top:10px; }
    .field input {
      flex:1; padding:10px 12px; border:1px solid var(--line); border-radius:10px; font-size:16px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Runes — Idle</h1>
    <div class="sub">Set a nickname, passively earn <strong>Cash</strong> every 0.5s, and roll for runes.</div>
  </header>

  <main>
    <div class="statbar">
      <div class="pill mono">Name: <span id="nick">—</span></div>
      <div class="pill mono">Cash: <span id="cash">0</span></div>
      <div class="pill mono">Income/tick: <span id="ptick">1</span> (every 0.5s)</div>
      <div class="pill mono small">Offline ticks: <span id="offline">0</span></div>
      <div class="pill mono">Auto-Rune: <span id="autoState">OFF</span></div>
    </div>

    <div class="actions">
      <button id="buyRuneBtn" disabled>Buy Rune (Cost: 10)</button>
      <button id="toggleAutoBtn" class="mutelink">Auto-Rune: OFF</button>
      <button id="renameBtn" class="mutelink">Change name</button>
      <button id="resetBtn" class="mutelink">Reset profile</button>
    </div>

    <div class="grid">
      <div class="card">
        <h3>Runes</h3>
        <div class="row"><span class="badge common">Common</span><span class="small">+x0.01</span><span id="cntCommon" class="mono">0</span></div>
        <div class="row"><span class="badge rare">Rare</span><span class="small">+x0.03</span><span id="cntRare" class="mono">0</span></div>
        <div class="row"><span class="badge epic">Epic</span><span class="small">+x0.10</span><span id="cntEpic" class="mono">0</span></div>
        <div class="row"><span class="badge legend">Legendary</span><span class="small">+x0.30</span><span id="cntLegendary" class="mono">0</span></div>
        <div class="row"><span class="badge mythic">Mythic</span><span class="small">+x1.00</span><span id="cntMythic" class="mono">0</span></div>
        <hr />
        <div class="row"><strong>Total rune bonus</strong><span id="runeBonus" class="mono">+x0.00</span></div>
        <div class="row"><strong>Last drops</strong><span id="lastRune" class="mono">—</span></div>
      </div>

      <div class="card">
        <h3>Upgrades</h3>
        <div class="row">
          <div>
            <div><strong>Luck</strong> <span class="small">(bias towards rarer)</span></div>
            <div class="small">Level: <span id="luckLvl" class="mono">0</span> | Mult: <span id="luckMul" class="mono">1.00×</span></div>
          </div>
          <button id="buyLuckBtn">Buy (Cost: <span id="luckCost">10</span>)</button>
        </div>
        <div class="row">
          <div>
            <div><strong>Bulk</strong> <span class="small">(rolls per purchase)</span></div>
            <div class="small">Level: <span id="bulkLvl" class="mono">0</span> | Rolls/purchase: <span id="bulkAmt" class="mono">1</span></div>
          </div>
          <button id="buyBulkBtn">Buy (Cost: <span id="bulkCost">50</span>)</button>
        </div>
      </div>

      <div class="card">
        <h3>Leaderboard — Top 10 Cash (Global)</h3>
        <table class="lb-table" aria-label="Leaderboard">
          <thead>
            <tr><th>#</th><th>Name</th><th>Cash</th></tr>
          </thead>
        <tbody id="lbBody">
            <tr><td colspan="3" class="small">Loading…</td></tr>
          </tbody>
        </table>
        <div class="small" style="margin-top:8px;">Stored globally via Firebase.</div>
      </div>
    </div>
  </main>

  <!-- Name modal -->
  <div id="nameModal" class="modal-backdrop" style="display:none;">
    <div class="modal">
      <h2>Choose your nickname</h2>
      <p class="small">This will be saved locally and used on the global leaderboard.</p>
      <div class="field">
        <input id="nameInput" type="text" placeholder="e.g. Baksamm" maxlength="20" />
        <button id="saveNameBtn">OK</button>
      </div>
    </div>
  </div>

  <!-- GAME + FIREBASE (module) -->
  <script type="module">
    /********** FIREBASE BOOTSTRAP **********/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, collection, query, orderBy, limit, getDocs, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    // TODO: Replace with your Firebase project config
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
      projectId: "YOUR_PROJECT_ID",
      // appId, etc. optional
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    /********** GAME CONFIG **********/
    const TICK_MS = 500;
    const BASE_INCOME = 1;
    const RUNE_COST = 10;

    // Base rarity weights (probability ~ w / sum(w)), Luck multiplies higher indices more.
    const baseWeights = [
      { name:'Common',    w: 1/2,   bonus: 0.01 },
      { name:'Rare',      w: 1/5,   bonus: 0.03 },
      { name:'Epic',      w: 1/20,  bonus: 0.10 },
      { name:'Legendary', w: 1/100, bonus: 0.30 },
      { name:'Mythic',    w: 1/500, bonus: 1.00 },
    ];

    // Luck: cost = 10 * 2^lvl, weight multiplier per rarity index = 1.2^lvl
    const LUCK_BASE_COST = 10;
    const LUCK_COST_GROW = 2;
    const LUCK_STEP = 1.2;

    // Bulk: cost = 50 * 5^lvl, attempts = 1 + lvl
    const BULK_BASE_COST = 50;
    const BULK_COST_GROW = 5;

    /********** STORAGE (local for gameplay state) **********/
    const el = id => document.getElementById(id);
    const GLOBAL_KEY = 'runeIdleProfile';

    function defaultProfile(name='') {
      return {
        name,
        cash: 0,
        runes: { Common:0, Rare:0, Epic:0, Legendary:0, Mythic:0 },
        luckLevel: 0,
        bulkLevel: 0,
        autoRune: false,
        lastTickAt: Date.now()
      };
    }
    function loadProfile() {
      try { return JSON.parse(localStorage.getItem(GLOBAL_KEY) || 'null'); } catch { return null; }
    }
    function saveProfile() {
      localStorage.setItem(GLOBAL_KEY, JSON.stringify(profile));
      // also try to sync leaderboard (debounced by animation loop cadence)
      upsertGlobalLeaderboard().catch(()=>{});
    }
    let profile = loadProfile() || defaultProfile('');

    /********** UTILS **********/
    const fmtInt = n => Math.floor(n).toLocaleString();
    const fmt2 = x => Number(x).toFixed(2).replace(/\.?0+$/,'');
    const escapeHtml = s => s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));

    /********** PROBABILITY (with Luck) **********/
    function luckMultiplier() {
      return Math.pow(LUCK_STEP, profile.luckLevel);
    }
    function makeRarityTable() {
      const L = luckMultiplier();
      let sum = 0;
      const enriched = baseWeights.map((r, i) => {
        const w = r.w * Math.pow(L, i);
        sum += w;
        return { name:r.name, w, bonus:r.bonus };
      });
      let acc = 0;
      return enriched.map(e => {
        const p = e.w / sum;
        acc += p;
        return { name:e.name, p, cum:acc, bonus:e.bonus };
      });
    }
    let rarityTable = makeRarityTable();

    function rollRarityOnce() {
      const r = Math.random();
      for (const e of rarityTable) if (r <= e.cum) return e.name;
      return 'Common';
    }

    /********** ECONOMY **********/
    function totalRuneBonus() {
      const r = profile.runes;
      return r.Common*0.01 + r.Rare*0.03 + r.Epic*0.10 + r.Legendary*0.30 + r.Mythic*1.00;
    }
    function incomePerTick() {
      return BASE_INCOME * (1 + totalRuneBonus());
    }

    function buyRunesOnce() {
      if (profile.cash < RUNE_COST) return 0;
      const bulkMax = 1 + profile.bulkLevel;
      const affordable = Math.min(bulkMax, Math.floor(profile.cash / RUNE_COST));
      if (affordable <= 0) return 0;

      profile.cash -= affordable * RUNE_COST;

      const drops = [];
      for (let i=0;i<affordable;i++){
        const got = rollRarityOnce();
        profile.runes[got] += 1;
        drops.push(got);
      }
      profile.lastTickAt = Date.now();
      saveProfile();
      updateUI(drops);
      return affordable;
    }

    /********** UI HOOKS **********/
    const $nick = el('nick'), $cash = el('cash'), $ptick = el('ptick'), $offline = el('offline');
    const $buyRune = el('buyRuneBtn'), $toggleAuto = el('toggleAutoBtn'), $autoState = el('autoState');
    const $rename = el('renameBtn'), $reset = el('resetBtn');
    const $cnt = {
      Common: el('cntCommon'),
      Rare: el('cntRare'),
      Epic: el('cntEpic'),
      Legendary: el('cntLegendary'),
      Mythic: el('cntMythic'),
    };
    const $runeBonus = el('runeBonus'), $lastRune = el('lastRune');
    const $luckLvl = el('luckLvl'), $luckMul = el('luckMul'), $luckCost = el('luckCost'), $buyLuck = el('buyLuckBtn');
    const $bulkLvl = el('bulkLvl'), $bulkAmt = el('bulkAmt'), $bulkCost = el('bulkCost'), $buyBulk = el('buyBulkBtn');

    const $modal = el('nameModal'), $nameInput = el('nameInput'), $saveName = el('saveNameBtn');
    const $lbBody = el('lbBody');

    function luckCost(level = profile.luckLevel) { return LUCK_BASE_COST * Math.pow(LUCK_COST_GROW, level); }
    function bulkCost(level = profile.bulkLevel) { return BULK_BASE_COST * Math.pow(BULK_COST_GROW, level); }

    function updateUI(lastDrops = null, offlineTicks = 0) {
      $nick.textContent = profile.name || '—';
      $cash.textContent = fmtInt(profile.cash);
      $ptick.textContent = incomePerTick().toFixed(2);
      $offline.textContent = offlineTicks;

      for (const k in $cnt) $cnt[k].textContent = profile.runes[k];
      $runeBonus.textContent = `+x${fmt2(totalRuneBonus())}`;
      $lastRune.textContent = lastDrops && lastDrops.length ? lastDrops.join(', ') : '—';

      $autoState.textContent = profile.autoRune ? 'ON' : 'OFF';
      $toggleAuto.textContent = `Auto-Rune: ${profile.autoRune ? 'ON' : 'OFF'}`;

      $luckLvl.textContent = profile.luckLevel;
      $luckMul.textContent = `${fmt2(luckMultiplier())}×`;
      $luckCost.textContent = fmtInt(luckCost());
      $buyLuck.disabled = profile.cash < luckCost();

      $bulkLvl.textContent = profile.bulkLevel;
      $bulkAmt.textContent = 1 + profile.bulkLevel;
      $bulkCost.textContent = fmtInt(bulkCost());
      $buyBulk.disabled = profile.cash < bulkCost();

      $buyRune.disabled = profile.cash < RUNE_COST || !profile.name;
    }

    /********** MODAL (name) **********/
    function showNameModal(prefill='') {
      $nameInput.value = prefill;
      $modal.style.display = 'flex';
      $nameInput.focus();
    }
    function hideNameModal() { $modal.style.display = 'none'; }

    $saveName.addEventListener('click', async () => {
      const v = $nameInput.value.trim().slice(0,20);
      if (!v) return;
      profile.name = v;
      profile.lastTickAt = Date.now();
      saveProfile();
      hideNameModal();
      updateUI();
      // write name immediately to user doc so LB shows right away
      await ensureUserDoc();
      await upsertGlobalLeaderboard();
      await renderLeaderboard();
    });
    $nameInput.addEventListener('keydown', e => { if (e.key === 'Enter') $saveName.click(); });

    $rename.addEventListener('click', () => showNameModal(profile.name));
    $reset.addEventListener('click', async () => {
      if (!confirm('Reset your local profile? This does not delete leaderboard entry.')) return;
      profile = defaultProfile('');
      saveProfile();
      showNameModal('');
      updateUI();
      // keep leaderboard doc; it will only update when you earn again
      await renderLeaderboard();
    });

    /********** ACTIONS **********/
    $buyRune.addEventListener('click', () => { buyRunesOnce(); });
    $toggleAuto.addEventListener('click', () => { profile.autoRune = !profile.autoRune; saveProfile(); updateUI(); });

    $buyLuck.addEventListener('click', () => {
      const cost = luckCost();
      if (profile.cash < cost) return;
      profile.cash -= cost;
      profile.luckLevel += 1;
      rarityTable = makeRarityTable();
      saveProfile();
      updateUI();
    });

    $buyBulk.addEventListener('click', () => {
      const cost = bulkCost();
      if (profile.cash < cost) return;
      profile.cash -= cost;
      profile.bulkLevel += 1;
      saveProfile();
      updateUI();
    });

    /********** LOOP & OFFLINE **********/
    function applyOfflineGains(now=Date.now()) {
      const elapsed = Math.max(0, now - (profile.lastTickAt || now));
      const ticks = Math.floor(elapsed / TICK_MS);
      if (ticks > 0) {
        profile.cash += ticks * incomePerTick();
        profile.lastTickAt = now - (elapsed % TICK_MS);
        saveProfile();
      }
      return ticks;
    }

    let accMs = 0, lastNow = performance.now();
    async function loop(now) {
      const dt = now - lastNow; lastNow = now;
      accMs += dt;

      let progressed = false;
      while (accMs >= TICK_MS) {
        accMs -= TICK_MS;
        profile.cash += incomePerTick();
        if (profile.autoRune && profile.name) buyRunesOnce();
        profile.lastTickAt = Date.now();
        progressed = true;
      }

      // lightweight autosync every ~1.5s
      if (now % 1500 < 16 && progressed) {
        saveProfile();               // saves local + attempts LB upsert
        await upsertGlobalLeaderboard().catch(()=>{});
      }

      updateUI(null);
      requestAnimationFrame(loop);
    }

    /********** GLOBAL LEADERBOARD (Firestore) **********/
    // Collection layout:
    // - users/<uid> { name, bestCash, updated }
    // - leaderboard/<uid> { name, cash, updated }  (duplicate for simpler security/query; optional)
    //
    // We’ll only keep users/<uid> and query ordered by bestCash from there.

    const usersCol = collection(db, 'users');

    async function ensureUserDoc() {
      const user = auth.currentUser;
      if (!user) return;
      const ref = doc(usersCol, user.uid);
      const snap = await getDoc(ref);
      if (!snap.exists()) {
        await setDoc(ref, {
          name: profile.name || 'Anonymous',
          bestCash: Math.floor(profile.cash) || 0,
          updated: serverTimestamp()
        });
      } else {
        // keep name up to date (on rename)
        const cur = snap.data() || {};
        if ((profile.name && cur.name !== profile.name)) {
          await updateDoc(ref, { name: profile.name, updated: serverTimestamp() });
        }
      }
    }

    async function upsertGlobalLeaderboard() {
      const user = auth.currentUser;
      if (!user) return;
      const ref = doc(usersCol, user.uid);
      const snap = await getDoc(ref);
      const currentBest = snap.exists() ? (snap.data().bestCash || 0) : 0;
      const nowCash = Math.floor(profile.cash);
      if (!snap.exists()) {
        await setDoc(ref, {
          name: profile.name || 'Anonymous',
          bestCash: nowCash,
          updated: serverTimestamp()
        });
      } else if (nowCash > currentBest || (profile.name && snap.data().name !== profile.name)) {
        await updateDoc(ref, {
          name: profile.name || 'Anonymous',
          bestCash: Math.max(nowCash, currentBest),
          updated: serverTimestamp()
        });
      }
    }

    async function renderLeaderboard() {
      const $lbBody = document.getElementById('lbBody');
      $lbBody.innerHTML = `<tr><td colspan="3" class="small">Loading…</td></tr>`;
      try {
        const qTop = query(usersCol, orderBy('bestCash', 'desc'), limit(10));
        const res = await getDocs(qTop);
        const rows = [];
        let i = 1;
        res.forEach(docSnap => {
          const d = docSnap.data();
          const name = (d && d.name) ? d.name : 'Anonymous';
          const cash = (d && d.bestCash) ? d.bestCash : 0;
          rows.push(
            `<tr>
              <td class="rank">${i++}</td>
              <td>${escapeHtml(String(name))}</td>
              <td class="mono">${fmtInt(cash)}</td>
            </tr>`
          );
        });
        if (rows.length === 0) {
          $lbBody.innerHTML = `<tr><td colspan="3" class="small">No data yet</td></tr>`;
        } else {
          $lbBody.innerHTML = rows.join('');
        }
      } catch (e) {
        console.error(e);
        $lbBody.innerHTML = `<tr><td colspan="3" class="small">Failed to load leaderboard</td></tr>`;
      }
    }

    /********** INIT **********/
    let rarityReady = false;

    (async function init(){
      // Auth first
      await signInAnonymously(auth).catch(err => {
        console.error('Anonymous auth failed:', err);
        alert('Firebase auth failed. Check your firebaseConfig & internet.');
      });

      onAuthStateChanged(auth, async (user) => {
        if (!user) return;
        // local name prompt if empty
        if (!profile.name) showNameModal('');
        else hideNameModal();

        const offlineTicks = applyOfflineGains();
        rarityTable = makeRarityTable();
        updateUI(null, offlineTicks);

        await ensureUserDoc();
        await upsertGlobalLeaderboard();
        await renderLeaderboard();

        // Start loop
        requestAnimationFrame(ts => { lastNow = ts; requestAnimationFrame(loop); });
      });

      // Refresh LB every 10 seconds to see others progress
      setInterval(renderLeaderboard, 10000);
    })();

    // Live UI handlers are already attached above
  </script>

  <!--
  ========================= FIRESTORE SECURITY RULES =========================
  Paste this into Firestore → Rules (replace PROJECT_ID accordingly if needed).
  These rules:
    - allow anyone to read top scores,
    - allow each authenticated (anonymous) user to write only their own document,
    - only allow increasing bestCash (no cheating down/up weirdness),
    - allow updating name.
  ============================================================================
  rules_version = '2';
  service cloud.firestore {
    match /databases/{database}/documents {
      match /users/{userId} {
        allow read: if true; // public leaderboard

        allow create: if request.auth != null && request.auth.uid == userId
                      && request.resource.data.keys().hasOnly(['name','bestCash','updated'])
                      && request.resource.data.bestCash is int
                      && request.resource.data.bestCash >= 0
                      && request.resource.data.name is string
                      && request.resource.data.name.size() <= 20;

        allow update: if request.auth != null && request.auth.uid == userId
          && request.resource.data.keys().hasOnly(['name','bestCash','updated'])
          && request.resource.data.name is string
          && request.resource.data.name.size() <= 20
          // only allow bestCash to stay same or increase
          && request.resource.data.bestCash is int
          && request.resource.data.bestCash >= resource.data.bestCash;

        allow delete: if false; // no deletes via client
      }
    }
  }
  ============================================================================ -->
</body>
</html>
